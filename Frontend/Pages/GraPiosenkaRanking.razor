@page "/gra-piosenka-ranking"
@using System.Diagnostics
@using Frontend.Services
@using Frontend.Shared
@inject NavigationManager Navigation
@inject IJSRuntime JS
@inject AuthorizedHttpClient AuthHttp
@inject HttpClient Http
@inject TokenGuard Guard


<div class="game-fullscreen @(!Started ? "is-start" : "has-fixed-title") flex flex-col items-center justify-center min-h-screen text-center px-4">
    <h1 class="game-title">🎯 Jaka To Piosenka?</h1>

    @if (!Started)
    {
        <section class="song-hero">
            <div class="song-hero__chip">
                <i class="fas fa-bolt"></i>
                Tryb rankingowy
            </div>

            <h2 class="song-hero__title">Jaka To Piosenka?</h2>
            <p class="song-hero__subtitle">Czy jesteś gotowy na wyzwanie muzyczne?</p>

            <button class="btn-hero" @onclick="StartGame">
                <span class="btn-hero__glow"></span>
                <i class="fas fa-play"></i>
                <span>Start</span>
            </button>
        </section>
    }
    else if (IsRoundLoading || CurrentSong is null)
    {
        <div class="preloader" aria-busy="true" aria-live="polite">
            <i class="fas fa-compact-disc fa-spin" aria-hidden="true"></i>
            <p>Ładuję rundę…</p>
            <small>Losuję piosenkę i przygotowuję audio oraz timer.</small>
        </div>
    }
    else if (CurrentSong != null)
    {
        <div class="flex flex-col items-center gap-6 w-full max-w-3xl mt-6">

            <div class="volume-pro @(Muted ? "is-muted" : "")" style="--fill:@($"{Volume*100}%")">
                <button class="vol-btn" @onclick="ToggleMute" aria-label="Wycisz / Włącz dźwięk" title="Wycisz / Włącz">
                    <i class="@VolumeIcon"></i>
                </button>

                <input type="range"
                       class="pro-range"
                       min="0" max="100" step="1"
                       @bind-value="VolumeP"
                       @bind-value:event="oninput"
                       style="--fill:@($"{VolumeP}%")" />

                <span class="vol-value">@VolumeP%</span>
            </div>


            <audio src="@AudioUrl" @ref="AudioRef" crossorigin="anonymous"></audio>

            @if (!string.IsNullOrEmpty(AudioUrl))
            {
                <AudioVisualizer IsPlaying="@(Started && !Answered)" />
            }

            @if (Started && !Answered)
            {
                <div class="hud-timer hud-timer--xl" aria-live="polite">
                    <div id="base-timer" class="base-timer" role="timer" aria-label="Pozostały czas">
                        <svg class="base-timer__svg" viewBox="0 0 100 100">
                            <g class="base-timer__circle">
                                <circle class="base-timer__path-elapsed" cx="50" cy="50" r="45"></circle>
                                <path id="base-timer-path-remaining" stroke-dasharray="283"
                                      class="base-timer__path-remaining green"
                                      d="M 50, 50 m -45, 0 a 45,45 0 1,0 90,0 a 45,45 0 1,0 -90,0">
                                </path>
                            </g>
                        </svg>
                        <span id="base-timer-label" class="base-timer__label">0:20</span>
                    </div>
                </div>
            }

            @if (Answered)
            {

                <div class="result-modal" role="dialog" aria-modal="true">
                    <div class="result-header @(IsResultLoading ? "loading" : (LastGuessCorrect ? "win" : "lose"))">
                        <h3 class="result-title">
                            @(IsResultLoading ? "⏳ Liczenie wyniku…" : (LastGuessCorrect ? "🎉Udało ci się!🎉" : "❌Niestety nie tym razem!❌"))
                        </h3>
                        <p class="result-subtitle">
                            @(IsResultLoading ? "Przeliczam punkty i pozycję w rankingu…" : ResultMessage)
                        </p>
                    </div>
                    
                    @if (IsResultLoading)
                    {
                        <div class="result-loading">
                            <i class="fas fa-circle-notch fa-spin" aria-hidden="true"></i>
                            <span>Proszę czekać…</span>
                        </div>
                    }
                    else
                    {

                        <div class="result-body">
                            <div class="stats-grid">
                                <div class="stat">
                                    <div class="stat-label">⏱ Czas odpowiedzi</div>
                                    <div class="stat-value">@($"{LastAnswerDurationSec:0.00} s")</div>
                                </div>
                                <div class="stat">
                                    <div class="stat-label">🏅 Punkty za rundę</div>
                                    <div class="stat-value">@LastRoundPoints</div>
                                </div>
                                <div class="stat">
                                    <div class="stat-label">🏆 Pozycja w rankingu</div>
                                    <div class="stat-value rank">
                                        <span class="rank-num">#@PlayerStats?.RankingPosition</span>
                                        <i class="@RankIconClass" aria-hidden="true"></i>
                                    </div>
                                </div>
                                <div class="stat">
                                    <div class="stat-label">📈 % wygranych</div>
                                    <div class="stat-value">@($"{PlayerStats?.WinRate:P0}")</div>
                                </div>
                                <div class="stat">
                                    <div class="stat-label">🎮 Gier (ranking)</div>
                                    <div class="stat-value">@PlayerStats?.Games</div>
                                </div>
                                <div class="stat">
                                    <div class="stat-label">✔️ Trafionych</div>
                                    <div class="stat-value">@PlayerStats?.Correct</div>
                                </div>
                                <div class="stat">
                                    <div class="stat-label">❌ Nietrafionych</div>
                                    <div class="stat-value">@PlayerStats?.Incorrect</div>
                                </div>
                                <div class="stat">
                                    <div class="stat-label">⚡ Najszybsza odpowiedź</div>
                                    <div class="stat-value">@($"{(PlayerStats?.BestTimeSec ?? 0):0.00} s")</div>
                                </div>
                                <div class="stat">
                                    <div class="stat-label">⏳ Średni czas</div>
                                    <div class="stat-value">@($"{(PlayerStats?.AvgTimeSec ?? 0):0.00} s")</div>
                                </div>
                            </div>
                        </div>
                    }

                    <div class="result-actions">
                        <button class="btn-modal neutral" @onclick='() => Navigation.NavigateTo("/panel")'>
                            Wróć do panelu
                        </button>
                        <button class="btn-modal primary" @onclick="StartGame">
                            Dalej 
                        </button>
                    </div>

                    <button class="result-close" title="Zamknij"
                            @onclick='() => Navigation.NavigateTo("/panel")'>×</button>
                </div>
            }

           <div class="input-wrapper-guess" id="guess-wrapper">
    <div class="typeahead">
        <input class="guess-input typeahead__input"
               placeholder="🎵 Zgadnij tytuł…"
               value="@Guess"
               @oninput="OnInput"
               @onkeydown="OnKeyDown"
               @onfocus="() => OpenSuggestions = TitleSuggestions?.Any() == true"
               aria-autocomplete="list"
               aria-controls="title-suggestions"
               aria-expanded="@OpenSuggestions"
               aria-activedescendant="@(ActiveIndex >= 0 ? $"sug-{ActiveIndex}" : null)"
               disabled="@Answered" />

        <button class="submit-btn right-btn" @onclick="SubmitGuess" disabled="@Answered">
            ✅ Zatwierdź
        </button>



        <div class="typeahead__panel @(OpenSuggestions ? "is-open" : "")" id="title-suggestions" role="listbox">
            @if (SuggestionsLoading)
            {
                <ul class="sug-list">
                    @for (var i = 0; i < 5; i++)
                    {
                        <li class="sug-item is-skeleton">
                            <span class="sug-icon"></span>
                            <span class="skeleton-line w60"></span>
                            <kbd class="sug-kbd">Enter</kbd>
                        </li>
                    }
                </ul>
            }
            else if (TitleSuggestions.Any())
            {
                <ul class="sug-list">
                    @for (var i = 0; i < TitleSuggestions.Count; i++)
                    {
                        var t = TitleSuggestions[i];
                        <li id="@($"sug-{i}")"
                            role="option"
                            class="sug-item @(i == ActiveIndex ? "is-active" : "")"
                            @onmouseenter="@(() => ActiveIndex = i)"
                            @onmousedown="@(() => SelectSuggestion(t))">
                            <i class="fas fa-music sug-icon" aria-hidden="true"></i>
                            <div class="sug-text">@((MarkupString)HighlightMatch(t, Guess))</div>
                            <kbd class="sug-kbd">Enter</kbd>
                        </li>
                    }
                </ul>
                <div class="typeahead__footer hint">
                    <span><kbd>↑</kbd><kbd>↓</kbd> – wybór • <kbd>Enter</kbd> – wstaw • <kbd>Esc</kbd> – zamknij</span>
                </div>
            }
            else if (!SuggestionsLoading && OpenSuggestions)
            {
                <div class="typeahead__empty">
                    Brak podpowiedzi dla <strong>@Guess</strong>.
                </div>
            }
        </div>
    </div>
</div>
        </div>
    }
</div>

@code {


    protected class SongDto { public Guid Id { get; set; } public string Title { get; set; } = string.Empty; }
    protected class GuessResult
    {
        public bool Correct { get; set; }
        public int Score { get; set; }
        public int TotalScore { get; set; }
        public int RankingPosition { get; set; }
        public string CorrectTitle { get; set; } = "";
        public string? DisplayTitle { get; set; } 
    }
    private double Volume = 0.8; // 0..1
    private int VolumePercent => (int)Math.Round(Volume * 100);
    private string VolumeIcon =>
        (Muted || Volume <= 0.001) ? "fas fa-volume-mute"
        : (Volume < 0.34) ? "fas fa-volume-off"
        : (Volume < 0.67) ? "fas fa-volume-down"
        : "fas fa-volume-up";
    private bool LastGuessCorrect;
    private int LastAnswerDuration;
    private PlayerSongStats? PlayerStats;
    private int LastRoundPoints;
    protected SongDto? CurrentSong;
    protected string AudioUrl = "";
    protected ElementReference AudioRef;
    protected string Guess = string.Empty;
    protected bool Started = false;
    protected bool Answered = false;
    protected string ResultMessage = "";
    protected DateTime StartTime;
    private List<string> TitleSuggestions = new();
    private int Countdown = 20;
    private System.Timers.Timer? countdownTimer;
    private Guid GameSessionId = Guid.NewGuid();
    private bool AudioStarted = false;
    private bool Muted = false;
    private double Progress = 1.0;
    private System.Timers.Timer? progressTimer;
    private const double Radius = 45.0;
    private string StrokeStyle => 
        $"stroke-dasharray:{Circumference:F2} {Circumference:F2};" +
        $"stroke-dashoffset:{StrokeOffset():F2};" +
        $"stroke:{GetColor()};" +
        $"transition:stroke-dashoffset 0.1s linear, stroke 0.3s;";


    private bool OpenSuggestions = false;
    private bool SuggestionsLoading = false;
    private int ActiveIndex = -1;
    private CancellationTokenSource? _sugCts;


    private readonly Stopwatch _sw = new(); 
    private double LastAnswerDurationSec;

    private bool IsResultLoading = false;

    private bool IsRoundLoading = false;

    public class PlayerSongStats
    {
        public int Games { get; set; }
        public int Correct { get; set; }
        public int Incorrect { get; set; }
        public double WinRate { get; set; }
        public int RankingPosition { get; set; }
        public double BestTimeSec { get; set; }
        public double AvgTimeSec { get; set; }
        public int TotalScore { get; set; }
    }

    private int? PreRoundRank; 
    private string RankTrend = "same"; 
    private string RankIconClass => RankTrend switch
    {
        "up"   => "fas fa-arrow-up rank-up",
        "down" => "fas fa-arrow-down rank-down",
        _      => "fas fa-minus rank-same"
    };

    private double Circumference => 2 * Math.PI * Radius;

    private int _volumeP = 80; 
    private int VolumeP
    {
        get => _volumeP;
        set
        {
            if (_volumeP == value) return;
            _volumeP = value;

            Volume = Math.Clamp(value / 100.0, 0, 1); 
            if (!Muted)
            {
                _ = JS.InvokeVoidAsync("setAudioVolume", AudioRef, Volume);
            }
            
        }
    }


    private async void StartCountdown()
    {
        Countdown = 20;
        StartTime = DateTime.Now;

        try
        {
            await JS.InvokeVoidAsync("Timer.start", DotNetObjectReference.Create(this), GameSessionId, 20);
        }
        catch (JSException ex)
        {
            Console.WriteLine($"JS Error: {ex.Message}");
        }

    }


    private async Task OnInput(ChangeEventArgs e)
    {
        Guess = e.Value?.ToString() ?? string.Empty;

        _sugCts?.Cancel();
        TitleSuggestions ??= new();
        if (string.IsNullOrWhiteSpace(Guess) || Guess.Length < 2)
        {
            TitleSuggestions.Clear();
            OpenSuggestions = false;
            ActiveIndex = -1;
            SuggestionsLoading = false;
            await InvokeAsync(StateHasChanged);
            return;
        }

        SuggestionsLoading = true;
        OpenSuggestions = true;
        ActiveIndex = 0;
        await InvokeAsync(StateHasChanged);

        var cts = new CancellationTokenSource();
        _sugCts = cts;

        try
        {
            
            await Task.Delay(180, cts.Token);
            var url = $"/api/songs/titles?query={Uri.EscapeDataString(Guess)}";
            var resp = await Http.GetFromJsonAsync<List<string>>(url, cts.Token);
            TitleSuggestions = resp ?? new();
        }
        catch (TaskCanceledException) { return; }
        finally
        {
            if (!cts.IsCancellationRequested)
            {
                SuggestionsLoading = false;
                OpenSuggestions = TitleSuggestions.Count > 0;
                ActiveIndex = OpenSuggestions ? 0 : -1;
                await InvokeAsync(StateHasChanged);
            }
        }
    }


    private new void SelectSuggestion(string title)
    {
        Guess = title;
        TitleSuggestions.Clear();
        CloseSuggestions();
    }

    protected async Task StartGame()
    {
        if (!await Guard.EnsureValidTokenOrRedirect(Navigation.Uri)) return;

        GameSessionId = Guid.NewGuid();
        Started = true;

        Answered = false;
        IsResultLoading = false;
        IsRoundLoading = true;     
        ResultMessage = "";
        Guess = "";
        PlayerStats = null;
        LastAnswerDuration = 0;
        LastGuessCorrect = false;
        RankTrend = "same";

        await JS.InvokeVoidAsync("gameSession.registerBeforeUnload", GameSessionId);


        try
        {
            var clientForStart = await AuthHttp.GetClientAsync();
            await clientForStart.PostAsJsonAsync("/api/game/start", new
            {
                sessionId = GameSessionId,
                mode = "ranking",
                type = "song"
            });
        }
        catch (Exception ex)
        {
            Console.WriteLine($"❌ Błąd startu sesji: {ex.Message}");
        }

        try
        {
            var clientForPre = await AuthHttp.GetClientAsync();
            var pre = await clientForPre.GetFromJsonAsync<PlayerSongStats>("/api/stats/me/song-ranking");
            PreRoundRank = (pre?.RankingPosition ?? 0) > 0 ? pre!.RankingPosition : (int?)null;
        }
        catch { PreRoundRank = null; }

        var songs = await Http.GetFromJsonAsync<List<SongDto>>("/api/songs/random?count=1");
        if (songs is null || songs.Count == 0)
        {
            IsRoundLoading = false;
            ResultMessage = "Nie udało się wylosować piosenki. Spróbuj ponownie.";
            StateHasChanged();
            return;
        }

        CurrentSong = songs[0];
        AudioStarted = false;

        AudioUrl = $"https://localhost:7236/api/media/song-audio/{CurrentSong.Id}";
        await JS.InvokeVoidAsync("stopAudio", AudioRef);

        StateHasChanged();
        await Task.Delay(100);

        StartTime = DateTime.Now;
        _sw.Reset();
        _sw.Start();

        IsRoundLoading = false;  
        StateHasChanged();

        StartCountdown(); 
    }


    protected virtual async Task SubmitGuess()
    {
        if (CurrentSong == null || Answered) return; 

        Answered = true; 
        IsResultLoading = true; 

        countdownTimer?.Stop();
        progressTimer?.Stop();

        await JS.InvokeVoidAsync("Timer.stop");

        _sw.Stop();
        var durationMs = (int)_sw.ElapsedMilliseconds;  
        LastAnswerDurationSec = durationMs / 1000.0;  
        LastAnswerDuration = (int)Math.Round(LastAnswerDurationSec); 

        var request = new
        {
            itemId = CurrentSong.Id!,
            guessText = CleanGuess(Guess),
            mode = "ranking",
            duration = durationMs  
        };

        var client = await AuthHttp.GetClientAsync();
        var res = await client.PostAsJsonAsync("/api/guess/song", request);

        await client.PostAsJsonAsync("/api/game/finish", new { SessionId = GameSessionId });

        if (!res.IsSuccessStatusCode)
        {
            ResultMessage = "❌ Błąd serwera lub brak autoryzacji.";
            IsResultLoading = false;
            return;
        }

        var result = await res.Content.ReadFromJsonAsync<GuessResult>();

        LastGuessCorrect = result!.Correct;
        LastRoundPoints = result.Score;

        await JS.InvokeVoidAsync("stopAudio", AudioRef);

        ResultMessage = result!.Correct
            ? $"{result.DisplayTitle ?? result.CorrectTitle}"
            : $"{result.DisplayTitle ?? result.CorrectTitle}";


        try
        {
            PlayerStats = await client.GetFromJsonAsync<PlayerSongStats>("/api/stats/me/song-ranking");
            UpdateRankTrend(); 
        }
        catch
        {
            // log
        }

        if (LastGuessCorrect)
        {
            await JS.InvokeVoidAsync("confettiBlazor.fire", "left");
            await JS.InvokeVoidAsync("confettiBlazor.fire", "right");
        }

        IsResultLoading = false;   
        StateHasChanged();

    }

    [JSInvokable]
    public async Task TimeoutGuess(Guid sessionId)
    {
        if (sessionId != GameSessionId || Answered || !Started || CurrentSong is null)
            return;

        _sw.Stop();
        Answered = true;
        IsResultLoading = true;

        countdownTimer?.Stop();
        progressTimer?.Stop();

        await JS.InvokeVoidAsync("Timer.stop");
        await JS.InvokeVoidAsync("stopAudio", AudioRef);

        LastAnswerDurationSec = 20.0;
        LastAnswerDuration = 20;

        var client = await AuthHttp.GetClientAsync();
        var request = new
        {
            itemId = CurrentSong.Id,
            guessText = "",          
            mode = "ranking",
            duration = 20000  
        };

        try
        {
            var res = await client.PostAsJsonAsync("/api/guess/song", request);
            if (res.IsSuccessStatusCode)
            {
                var result = await res.Content.ReadFromJsonAsync<GuessResult>();
                LastGuessCorrect = result!.Correct;  
                LastRoundPoints = result.Score;   

                ResultMessage = result.DisplayTitle ?? result.CorrectTitle;

                PlayerStats = await client.GetFromJsonAsync<PlayerSongStats>("/api/stats/me/song-ranking");
                UpdateRankTrend(); 
            }
            else
            {
                ResultMessage = "⏱ Czas minął!";
                LastGuessCorrect = false;
                LastRoundPoints = -50;
            }
        }
        catch
        {
            ResultMessage = "⏱ Czas minął!";
            LastGuessCorrect = false;
            LastRoundPoints = -50;
        }

        IsResultLoading = false;
        StateHasChanged();
    }


    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (Started && CurrentSong != null && !Answered && AudioRef.Context != null && !AudioStarted)
        {
            AudioStarted = true;

            await Task.Delay(200); 

            await JS.InvokeVoidAsync("playAudio", AudioRef);

            await JS.InvokeVoidAsync("startTimeout",
                DotNetObjectReference.Create(this),
                "invokeMethodAsync",
                nameof(TimeoutGuess),
                GameSessionId,
                20000);
        }
    } 

    private string CleanGuess(string input)
    {
        var match = System.Text.RegularExpressions.Regex.Match(input, @"^(.*?)(?: \(\d{4}\))?$");
        if (match.Success)
        {
            var cleaned = match.Groups[1].Value;
            if (cleaned.Contains(" - "))
                return cleaned.Split(" - ")[1].Trim();
            return cleaned.Trim();
        }
        return input.Trim();
    }

    private async Task OnVolumeChanged(ChangeEventArgs e)
    {
        var value = e.Value?.ToString();
        if (double.TryParse(value, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out var volume))
        {
            await JS.InvokeVoidAsync("setAudioVolume", AudioRef, volume);
        }
    }

    private double StrokeOffset() => Progress * Circumference;

    private string GetColor()
    {
        if (Countdown > 13)
            return "#22c55e"; // green
        else if (Countdown > 6)
            return "#f59e0b"; // orange
        else
            return "#ef4444"; // red
    }

    private async Task OnVolumeInput(ChangeEventArgs e)
    {
        if (double.TryParse(e.Value?.ToString(), out var p))
        {
            Volume = Math.Clamp(p / 100.0, 0, 1);
            if (!Muted)
                await JS.InvokeVoidAsync("setAudioVolume", AudioRef, Volume);
            StateHasChanged(); 
        }
    }

    private async Task ToggleMute()
    {
        Muted = !Muted;
        if (Muted)
            await JS.InvokeVoidAsync("muteAudio", AudioRef);
        else
            await JS.InvokeVoidAsync("unmuteAudio", AudioRef);
        if (!Muted)
            await JS.InvokeVoidAsync("setAudioVolume", AudioRef, Volume);
    }

    private async Task OnKeyDown(KeyboardEventArgs e)
    {
        if (Answered) return;

        switch (e.Key)
        {
            case "ArrowDown":
                if (TitleSuggestions.Count > 0)
                {
                    OpenSuggestions = true;
                    ActiveIndex = (ActiveIndex + 1) % TitleSuggestions.Count;
                }
                break;

            case "ArrowUp":
                if (TitleSuggestions.Count > 0)
                {
                    OpenSuggestions = true;
                    ActiveIndex = (ActiveIndex <= 0 ? TitleSuggestions.Count - 1 : ActiveIndex - 1);
                }
                break;

            case "Enter":
                if (OpenSuggestions && ActiveIndex >= 0 && ActiveIndex < TitleSuggestions.Count)
                    SelectSuggestion(TitleSuggestions[ActiveIndex]);
                else
                    await SubmitGuess();
                break;

            case "Escape":
                CloseSuggestions();
                break;
        }
    }

    private void CloseSuggestions()
    {
        OpenSuggestions = false;
        ActiveIndex = -1;
        SuggestionsLoading = false;
    }

    
    private static string HighlightMatch(string text, string query)
    {
        if (string.IsNullOrWhiteSpace(text)) return System.Net.WebUtility.HtmlEncode(text);
        if (string.IsNullOrWhiteSpace(query)) return System.Net.WebUtility.HtmlEncode(text);

        var idx = text.IndexOf(query, StringComparison.OrdinalIgnoreCase);
        if (idx < 0) return System.Net.WebUtility.HtmlEncode(text);

        var before = System.Net.WebUtility.HtmlEncode(text[..idx]);
        var match  = System.Net.WebUtility.HtmlEncode(text.Substring(idx, query.Length));
        var after  = System.Net.WebUtility.HtmlEncode(text[(idx + query.Length)..]);

        return $"{before}<mark>{match}</mark>{after}";
    }

    private void UpdateRankTrend()
    {
        if (PreRoundRank.HasValue && PlayerStats is not null && PlayerStats.RankingPosition > 0)
        {
            if (PlayerStats.RankingPosition < PreRoundRank.Value) RankTrend = "up";
            else if (PlayerStats.RankingPosition > PreRoundRank.Value) RankTrend = "down";
            else RankTrend = "same";
        }
        else
        {
            RankTrend = "same";
        }
    }
}
